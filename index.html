<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>料理排程器</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    .section { margin-top: 2em; }
    .timeline-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .timeline-label {
      width: 80px;
      font-weight: bold;
    }

    .step-container {
      flex-grow: 1;
      position: relative;
      height: 40px; /* 降低高度 */
      background: #f0f0f0;
      max-width: calc(100vw - 130px); /* 讓排程區寬度跟隨視窗寬度，左側標籤約80px，再留約50px右邊距 */
      margin-right: 10px; /* 右邊距，避免貼邊 */
    }

    .step-block {
      position: absolute;
      top: 2.5px;  /* 往下移動一點，讓上下有空隙 */
      height: 30px; /* 縮矮高度 */
      border-radius: 4px;
      padding: 3px 6px;
      font-size: 12px;
      color: #fff;
      white-space: normal;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1.2em;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 3px; /* 文字間隙 */
      /* 移除 margin-right，改用計算 left 保持間隔 */
    }

    label { margin-right: 10px; display: inline-block; }
  </style>
</head>
<body>
  <h1>料理排程器</h1>

  <!-- 選擇鍋具 -->
  <div class="section">
    <h2>1. 選擇擁有的鍋具</h2>
    <input type="checkbox" name="tools" value="無鍋具"> 無鍋具
    <input type="checkbox" name="tools" value="電鍋"> 電鍋
    <input type="checkbox" name="tools" value="湯鍋"> 湯鍋
    <input type="checkbox" name="tools" value="炒鍋"> 炒鍋
  </div>

  <!-- 可選料理 -->
  <div class="section">
    <h2>2. 可做料理（點擊加入下方清單）</h2>
    <div id="filteredRecipes"></div>
  </div>

  <!-- 已選料理 -->
  <div class="section">
    <h2>3. 所選料理（勾選欲排程項目）</h2>
    <div id="selectedRecipes"></div>
  </div>

  <!-- 排程 -->
  <div class="section">
    <button id="btnSchedule">產生排程</button>
    <h2>排程結果</h2>
    <div id="scheduleResult"></div>
  </div>

  <script type="module">
    import { recipes } from './recipes.js';
    import { scheduleRecipes } from './scheduler.js';

    const filteredContainer = document.getElementById('filteredRecipes');
    const selectedContainer = document.getElementById('selectedRecipes');
    const scheduleResult = document.getElementById('scheduleResult');

    let selectedRecipeSet = new Set();

    function getSelectedTools() {
      return Array.from(document.querySelectorAll('input[name="tools"]:checked')).map(cb => cb.value);
    }

    function getUsedTools(recipe) {
      return recipe.steps.map(s => s.tool).filter(Boolean);
    }

    function renderFilteredRecipes() {
      const tools = getSelectedTools();
      filteredContainer.innerHTML = '';

      recipes.forEach(r => {
        const toolsNeeded = getUsedTools(r);
        const isNoToolNeeded = toolsNeeded.length === 0;
        const hasNoToolOption = tools.includes('無鍋具');

        const allToolsAvailable =
          (isNoToolNeeded && hasNoToolOption) ||
          (!isNoToolNeeded && toolsNeeded.every(t => tools.includes(t)));
        if (allToolsAvailable) {
          const btn = document.createElement('button');
          btn.textContent = r.name;
          btn.onclick = () => {
            selectedRecipeSet.add(r.id);
            renderSelectedRecipes();
          };
          filteredContainer.appendChild(btn);
        }
      });
    }

    function renderSelectedRecipes() {
      selectedContainer.innerHTML = '';
      recipes
        .filter(r => selectedRecipeSet.has(r.id))
        .forEach(r => {
          const label = document.createElement('label');
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.value = r.id;
          cb.name = 'selected';
          label.appendChild(cb);
          label.appendChild(document.createTextNode(` ${r.name}`));
          selectedContainer.appendChild(label);
        });
    }

    function getColor(recipeId) {
      const colors = ['#5DADE2', '#58D68D', '#F5B041', '#AF7AC5', '#EC7063', '#52BE80', '#F4D03F', '#85929E'];
      return colors[recipeId % colors.length];
    }

    function renderSchedule(schedule) {
      const rows = {
        '無鍋具': [],
        '炒鍋': [],
        '電鍋': [],
        '湯鍋': [],
      };

      schedule.forEach(s => {
        const tool = s.tool || '無鍋具';
        rows[tool].push(s);
      });

      scheduleResult.innerHTML = '';

      Object.entries(rows).forEach(([tool, steps]) => {
        const row = document.createElement('div');
        row.className = 'timeline-row';

        const label = document.createElement('div');
        label.className = 'timeline-label';
        label.textContent = tool;
        row.appendChild(label);

        const container = document.createElement('div');
        container.className = 'step-container';

        const gap = 7; // 區塊間距 px
        let lastEnd = 0;

        // 確保依開始時間排序，避免邏輯錯亂
        steps.sort((a, b) => a.start - b.start);

        steps.forEach(s => {
          const block = document.createElement('div');
          const duration = s.end - s.start;
          block.className = 'step-block';

          // 計算理想的 left
          let leftPos = s.start * 15;

          // 如果前一個區塊結束加間距超過這個起點，往右推
          if (leftPos < lastEnd + gap) {
            leftPos = lastEnd + gap;
          }

          block.style.left = `${leftPos}px`;

          // 寬度減掉間距 gap，避免區塊貼齊，且設最小寬度 5px
          let widthPx = duration * 15 - gap;
          if (widthPx < 5) widthPx = 5;

          block.style.width = `${widthPx}px`;
          block.style.backgroundColor = getColor(s.recipeId);

          const recipe = recipes.find(r => r.id === s.recipeId);
          const onlyOneStep = recipe && recipe.steps.length === 1;

          if (onlyOneStep) {
            block.innerHTML = `
              <div>${s.recipeName}</div>
              <div>(${duration}分)</div>
            `;
          } else {
            block.innerHTML = `
              <div>${s.recipeName}</div>
              <div>${s.stepName} (${duration}分)</div>
            `;
          }

          container.appendChild(block);

          // 更新 lastEnd：左邊起點 + 區塊寬度 + 間距 gap
          lastEnd = leftPos + widthPx + gap;
        });

        row.appendChild(container);
        scheduleResult.appendChild(row);
      });
    }

    document.querySelectorAll('input[name="tools"]').forEach(cb =>
      cb.addEventListener('change', renderFilteredRecipes)
    );

    document.getElementById('btnSchedule').addEventListener('click', () => {
      const tools = getSelectedTools();
      const selectedIds = Array.from(document.querySelectorAll('input[name="selected"]:checked')).map(i => Number(i.value));

      if (selectedIds.length === 0) {
        alert('請先從已選料理中勾選要排程的料理');
        return;
      }

      const schedule = scheduleRecipes(selectedIds, tools);

      // 找最大結束時間
      let maxEnd = 0;
      schedule.forEach(s => {
        if (s.end > maxEnd) maxEnd = s.end;
      });

      if (maxEnd > 120) {
        alert('哪有人煮晚餐超過兩個小時!!!');
        return; // 超過兩小時就不繪製排程
      }

      renderSchedule(schedule);
    });


    renderFilteredRecipes();
  </script>
</body>
</html>
